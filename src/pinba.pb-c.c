/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: pinba.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#define PROTOBUF_C__WRONG_MESSAGE       -1
#define PROTOBUF_C__NOT_ENOUGH_MEMORY   -2

#include "pinba.pb-c.h"

static ProtobufCAllocator protobuf_c_default_allocator = protobuf_c_default_allocator_init;

void pinba__request__init
                     (Pinba__Request *message)
{
  static Pinba__Request init_value = PINBA__REQUEST__INIT;
  *message = init_value;
}

size_t pinba__request__get_packed_size
                     (const Pinba__Request *message)
{
  assert(message->base.descriptor == &pinba__request__descriptor);
  unsigned i;
  size_t rv;
  size_t sz = 0;
  const size_t hostname__tag_size = 1;
  const size_t server_name__tag_size = 1;
  const size_t script_name__tag_size = 1;
  const size_t request_count__tag_size = 1;
  const size_t document_size__tag_size = 1;
  const size_t memory_peak__tag_size = 1;
  const size_t request_time__tag_size = 1;
  const size_t ru_utime__tag_size = 1;
  const size_t ru_stime__tag_size = 1;
  const size_t timer_hit_count__tag_size = 1;
  const size_t timer_value__tag_size = 1;
  const size_t timer_tag_count__tag_size = 1;
  const size_t timer_tag_name__tag_size = 1;
  const size_t timer_tag_value__tag_size = 1;
  const size_t dictionary__tag_size = 1;
  const size_t status__tag_size = 2;
  const size_t memory_footprint__tag_size = 2;
  const size_t requests__tag_size = 2;
  const size_t schema__tag_size = 2;
  const size_t tag_name__tag_size = 2;
  const size_t tag_value__tag_size = 2;
  const size_t timer_ru_utime__tag_size = 2;
  const size_t timer_ru_stime__tag_size = 2;
  sz += hostname__tag_size;
  sz += string_size(message->hostname);
  sz += server_name__tag_size;
  sz += string_size(message->server_name);
  sz += script_name__tag_size;
  sz += string_size(message->script_name);
  sz += request_count__tag_size;
  sz += uint32_size(message->request_count);
  sz += document_size__tag_size;
  sz += uint32_size(message->document_size);
  sz += memory_peak__tag_size;
  sz += uint32_size(message->memory_peak);
  sz += request_time__tag_size;
  sz += 4;
  sz += ru_utime__tag_size;
  sz += 4;
  sz += ru_stime__tag_size;
  sz += 4;
  if (message->n_timer_hit_count > 0) {
    sz += timer_hit_count__tag_size * message->n_timer_hit_count;
    rv = 0;
    for (i = 0; i < message->n_timer_hit_count; i++) {
      rv += uint32_size(message->timer_hit_count[i]);
    }
    sz += rv;
  }
  if (message->n_timer_value > 0) {
    sz += timer_value__tag_size * message->n_timer_value;
    rv = 4 * message->n_timer_value;
    sz += rv;
  }
  if (message->n_timer_tag_count > 0) {
    sz += timer_tag_count__tag_size * message->n_timer_tag_count;
    rv = 0;
    for (i = 0; i < message->n_timer_tag_count; i++) {
      rv += uint32_size(message->timer_tag_count[i]);
    }
    sz += rv;
  }
  if (message->n_timer_tag_name > 0) {
    sz += timer_tag_name__tag_size * message->n_timer_tag_name;
    rv = 0;
    for (i = 0; i < message->n_timer_tag_name; i++) {
      rv += uint32_size(message->timer_tag_name[i]);
    }
    sz += rv;
  }
  if (message->n_timer_tag_value > 0) {
    sz += timer_tag_value__tag_size * message->n_timer_tag_value;
    rv = 0;
    for (i = 0; i < message->n_timer_tag_value; i++) {
      rv += uint32_size(message->timer_tag_value[i]);
    }
    sz += rv;
  }
  if (message->n_dictionary > 0) {
    sz += dictionary__tag_size * message->n_dictionary;
    rv = 0;
    for (i = 0; i < message->n_dictionary; i++) {
      rv += string_size(message->dictionary[i]);
    }
    sz += rv;
  }
  if (message->has_status) {
    sz += status__tag_size;
    sz += uint32_size(message->status);
  }
  if (message->has_memory_footprint) {
    sz += memory_footprint__tag_size;
    sz += uint32_size(message->memory_footprint);
  }
  if (message->n_requests > 0) {
    sz += requests__tag_size * message->n_requests;
    rv = 0;
    for (i = 0; i < message->n_requests; i++) {
      rv += submessage_size(pinba__request__get_packed_size(message->requests[i]));
    }
    sz += rv;
  }
  if (message->schema != NULL) {
    sz += schema__tag_size;
    sz += string_size(message->schema);
  }
  if (message->n_tag_name > 0) {
    sz += tag_name__tag_size * message->n_tag_name;
    rv = 0;
    for (i = 0; i < message->n_tag_name; i++) {
      rv += uint32_size(message->tag_name[i]);
    }
    sz += rv;
  }
  if (message->n_tag_value > 0) {
    sz += tag_value__tag_size * message->n_tag_value;
    rv = 0;
    for (i = 0; i < message->n_tag_value; i++) {
      rv += uint32_size(message->tag_value[i]);
    }
    sz += rv;
  }
  if (message->n_timer_ru_utime > 0) {
    sz += timer_ru_utime__tag_size * message->n_timer_ru_utime;
    rv = 4 * message->n_timer_ru_utime;
    sz += rv;
  }
  if (message->n_timer_ru_stime > 0) {
    sz += timer_ru_stime__tag_size * message->n_timer_ru_stime;
    rv = 4 * message->n_timer_ru_stime;
    sz += rv;
  }
  return sz;
}

size_t pinba__request__pack
                     (const Pinba__Request *message,
                      uint8_t *out)
{
  assert(message->base.descriptor == &pinba__request__descriptor);
  uint8_t *varint_length_p;
  size_t varint_length, length, reserved_length;
  unsigned i;
  uint8_t *p = out;
  *p++ = '\xa';
  p += string_pack(message->hostname, p);
  *p++ = '\x12';
  p += string_pack(message->server_name, p);
  *p++ = '\x1a';
  p += string_pack(message->script_name, p);
  *p++ = '\x20';
  p += uint32_pack(message->request_count, p);
  *p++ = '\x28';
  p += uint32_pack(message->document_size, p);
  *p++ = '\x30';
  p += uint32_pack(message->memory_peak, p);
  *p++ = '\x3d';
  p += fixed32_pack_p(&message->request_time, p);
  *p++ = '\x45';
  p += fixed32_pack_p(&message->ru_utime, p);
  *p++ = '\x4d';
  p += fixed32_pack_p(&message->ru_stime, p);
  for (i = 0; i < message->n_timer_hit_count; i++) {
    *p++ = '\x50';
    p += uint32_pack(message->timer_hit_count[i], p);
  }
  for (i = 0; i < message->n_timer_value; i++) {
    *p++ = '\x5d';
    p += fixed32_pack_p(&message->timer_value[i], p);
  }
  for (i = 0; i < message->n_timer_tag_count; i++) {
    *p++ = '\x60';
    p += uint32_pack(message->timer_tag_count[i], p);
  }
  for (i = 0; i < message->n_timer_tag_name; i++) {
    *p++ = '\x68';
    p += uint32_pack(message->timer_tag_name[i], p);
  }
  for (i = 0; i < message->n_timer_tag_value; i++) {
    *p++ = '\x70';
    p += uint32_pack(message->timer_tag_value[i], p);
  }
  for (i = 0; i < message->n_dictionary; i++) {
    *p++ = '\x7a';
    p += string_pack(message->dictionary[i], p);
  }
  if (message->has_status) {
    *p++ = '\x80'; *p++ = '\x1';
    p += uint32_pack(message->status, p);
  }
  if (message->has_memory_footprint) {
    *p++ = '\x88'; *p++ = '\x1';
    p += uint32_pack(message->memory_footprint, p);
  }
  for (i = 0; i < message->n_requests; i++) {
    *p++ = '\x92'; *p++ = '\x1';
    varint_length_p = p;
    reserved_length = 1;
    p++;
    p += pinba__request__pack(message->requests[i], p);
    length = p - (varint_length_p + reserved_length);
    varint_length = uint32_size(length);
    if (varint_length != reserved_length) {
      memmove(varint_length_p + varint_length, varint_length_p + reserved_length, length);
      p += varint_length - reserved_length;
    }
    uint32_pack(length, varint_length_p);
  }
  if (message->schema != NULL) {
    *p++ = '\x9a'; *p++ = '\x1';
    p += string_pack(message->schema, p);
  }
  for (i = 0; i < message->n_tag_name; i++) {
    *p++ = '\xa0'; *p++ = '\x1';
    p += uint32_pack(message->tag_name[i], p);
  }
  for (i = 0; i < message->n_tag_value; i++) {
    *p++ = '\xa8'; *p++ = '\x1';
    p += uint32_pack(message->tag_value[i], p);
  }
  for (i = 0; i < message->n_timer_ru_utime; i++) {
    *p++ = '\xb5'; *p++ = '\x1';
    p += fixed32_pack_p(&message->timer_ru_utime[i], p);
  }
  for (i = 0; i < message->n_timer_ru_stime; i++) {
    *p++ = '\xbd'; *p++ = '\x1';
    p += fixed32_pack_p(&message->timer_ru_stime[i], p);
  }
  return p - out;
}

size_t pinba__request__pack_to_buffer
                     (const Pinba__Request *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &pinba__request__descriptor);
  unsigned i;
  size_t rv;
  uint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];
  uint8_t simple_buffer_scratch[256];
  ProtobufCBufferSimple simple_buffer;
  size_t len;
  size_t sz = 0;
  scratch[0] = '\xa';
  len = strlen(message->hostname);
  rv = 1 + uint32_pack(len, scratch + 1);
  buffer->append(buffer, rv, scratch);
  buffer->append(buffer, len, (const uint8_t *) message->hostname);
  sz += rv + len;
  scratch[0] = '\x12';
  len = strlen(message->server_name);
  rv = 1 + uint32_pack(len, scratch + 1);
  buffer->append(buffer, rv, scratch);
  buffer->append(buffer, len, (const uint8_t *) message->server_name);
  sz += rv + len;
  scratch[0] = '\x1a';
  len = strlen(message->script_name);
  rv = 1 + uint32_pack(len, scratch + 1);
  buffer->append(buffer, rv, scratch);
  buffer->append(buffer, len, (const uint8_t *) message->script_name);
  sz += rv + len;
  scratch[0] = '\x20';
  rv = 1 + uint32_pack(message->request_count, scratch + 1);
  buffer->append(buffer, rv, scratch); sz += rv;
  scratch[0] = '\x28';
  rv = 1 + uint32_pack(message->document_size, scratch + 1);
  buffer->append(buffer, rv, scratch); sz += rv;
  scratch[0] = '\x30';
  rv = 1 + uint32_pack(message->memory_peak, scratch + 1);
  buffer->append(buffer, rv, scratch); sz += rv;
  scratch[0] = '\x3d';
  rv = 1 + fixed32_pack_p(&message->request_time, scratch + 1);
  buffer->append(buffer, rv, scratch); sz += rv;
  scratch[0] = '\x45';
  rv = 1 + fixed32_pack_p(&message->ru_utime, scratch + 1);
  buffer->append(buffer, rv, scratch); sz += rv;
  scratch[0] = '\x4d';
  rv = 1 + fixed32_pack_p(&message->ru_stime, scratch + 1);
  buffer->append(buffer, rv, scratch); sz += rv;
  for (i = 0; i < message->n_timer_hit_count; i++) {
    scratch[0] = '\x50';
    rv = 1 + uint32_pack(message->timer_hit_count[i], scratch + 1);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_timer_value; i++) {
    scratch[0] = '\x5d';
    rv = 1 + fixed32_pack_p(&message->timer_value[i], scratch + 1);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_timer_tag_count; i++) {
    scratch[0] = '\x60';
    rv = 1 + uint32_pack(message->timer_tag_count[i], scratch + 1);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_timer_tag_name; i++) {
    scratch[0] = '\x68';
    rv = 1 + uint32_pack(message->timer_tag_name[i], scratch + 1);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_timer_tag_value; i++) {
    scratch[0] = '\x70';
    rv = 1 + uint32_pack(message->timer_tag_value[i], scratch + 1);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_dictionary; i++) {
    scratch[0] = '\x7a';
    len = strlen(message->dictionary[i]);
    rv = 1 + uint32_pack(len, scratch + 1);
    buffer->append(buffer, rv, scratch);
    buffer->append(buffer, len, (const uint8_t *) message->dictionary[i]);
    sz += rv + len;
  }
  if (message->has_status) {
    scratch[0] = '\x80';
    scratch[1] = '\x1';
    rv = 2 + uint32_pack(message->status, scratch + 2);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  if (message->has_memory_footprint) {
    scratch[0] = '\x88';
    scratch[1] = '\x1';
    rv = 2 + uint32_pack(message->memory_footprint, scratch + 2);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_requests; i++) {
    scratch[0] = '\x92';
    scratch[1] = '\x1';
    simple_buffer = (ProtobufCBufferSimple) PROTOBUF_C_BUFFER_SIMPLE_INIT(simple_buffer_scratch);
    len = pinba__request__pack_to_buffer(message->requests[i], &simple_buffer.base);
    rv = 2 + uint32_pack(len, scratch + 2);
    buffer->append(buffer, rv, scratch);
    buffer->append(buffer, len, simple_buffer.data);
    sz += rv + len;
    PROTOBUF_C_BUFFER_SIMPLE_CLEAR(&simple_buffer);
  }
  if (message->schema != NULL) {
    scratch[0] = '\x9a';
    scratch[1] = '\x1';
    len = strlen(message->schema);
    rv = 2 + uint32_pack(len, scratch + 2);
    buffer->append(buffer, rv, scratch);
    buffer->append(buffer, len, (const uint8_t *) message->schema);
    sz += rv + len;
  }
  for (i = 0; i < message->n_tag_name; i++) {
    scratch[0] = '\xa0';
    scratch[1] = '\x1';
    rv = 2 + uint32_pack(message->tag_name[i], scratch + 2);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_tag_value; i++) {
    scratch[0] = '\xa8';
    scratch[1] = '\x1';
    rv = 2 + uint32_pack(message->tag_value[i], scratch + 2);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_timer_ru_utime; i++) {
    scratch[0] = '\xb5';
    scratch[1] = '\x1';
    rv = 2 + fixed32_pack_p(&message->timer_ru_utime[i], scratch + 2);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  for (i = 0; i < message->n_timer_ru_stime; i++) {
    scratch[0] = '\xbd';
    scratch[1] = '\x1';
    rv = 2 + fixed32_pack_p(&message->timer_ru_stime[i], scratch + 2);
    buffer->append(buffer, rv, scratch); sz += rv;
  }
  return sz;
}

int pinba__request__unpack_merge
                     (Pinba__Request *message,
                      const uint8_t *buffer, size_t buffer_size,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &pinba__request__descriptor);
  const uint8_t *buffer_end = buffer+buffer_size;
  const uint8_t* tmp_buffer_pointer = NULL;
  int32_t t = 0;
  uint32_t length = 0;
  uint64_t required_fields[1] = {0};

  while (buffer < buffer_end) {
    switch(buffer[0]) {
      case 0x80:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ((buffer=read_uint32(&message->status, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            message->has_status = 1;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x88:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ((buffer=read_uint32(&message->memory_footprint, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            message->has_memory_footprint = 1;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0xa:
        buffer += 1;
        if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        if ((message->hostname = memory_allocate_copy(length+1,
            allocator, buffer, length)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
        message->hostname[length] = 0;
        buffer += length;
        required_fields[0] |= (1UL << 0);
        continue;
      case 0x12:
        buffer += 1;
        if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        if ((message->server_name = memory_allocate_copy(length+1,
            allocator, buffer, length)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
        message->server_name[length] = 0;
        buffer += length;
        required_fields[0] |= (1UL << 1);
        continue;
      case 0x1a:
        buffer += 1;
        if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        if ((message->script_name = memory_allocate_copy(length+1,
            allocator, buffer, length)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
        message->script_name[length] = 0;
        buffer += length;
        required_fields[0] |= (1UL << 2);
        continue;
      case 0x9a:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
            if ((message->schema = memory_allocate_copy(length+1,
                allocator, buffer, length)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            message->schema[length] = 0;
            buffer += length;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x20:
        buffer += 1;
        if ((buffer=read_uint32(&message->request_count, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        required_fields[0] |= (1UL << 3);
        continue;
      case 0xa2:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            tmp_buffer_pointer = buffer+t;
            if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
            while (buffer < tmp_buffer_pointer) {
              if ( ((message->n_tag_name-1) & (message->n_tag_name)) == 0) {
                if (message->n_tag_name == 0) {
                  if ((message->tag_name = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                } else if (message->n_tag_name >= 8) {
                  void *new_ptr = memory_allocate_copy(2*message->n_tag_name*sizeof(uint32_t), allocator,
                    (uint8_t*)message->tag_name, message->n_tag_name*sizeof(uint32_t));
                  if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                  message->tag_name = new_ptr;
                }
              }
              if ((buffer=read_uint32(&message->tag_name[message->n_tag_name], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
              message->n_tag_name++;
            }
            if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x28:
        buffer += 1;
        if ((buffer=read_uint32(&message->document_size, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        required_fields[0] |= (1UL << 4);
        continue;
      case 0xaa:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            tmp_buffer_pointer = buffer+t;
            if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
            while (buffer < tmp_buffer_pointer) {
              if ( ((message->n_tag_value-1) & (message->n_tag_value)) == 0) {
                if (message->n_tag_value == 0) {
                  if ((message->tag_value = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                } else if (message->n_tag_value >= 8) {
                  void *new_ptr = memory_allocate_copy(2*message->n_tag_value*sizeof(uint32_t), allocator,
                    (uint8_t*)message->tag_value, message->n_tag_value*sizeof(uint32_t));
                  if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                  message->tag_value = new_ptr;
                }
              }
              if ((buffer=read_uint32(&message->tag_value[message->n_tag_value], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
              message->n_tag_value++;
            }
            if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x30:
        buffer += 1;
        if ((buffer=read_uint32(&message->memory_peak, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        required_fields[0] |= (1UL << 5);
        continue;
      case 0xb2:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            tmp_buffer_pointer = buffer+t;
            if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
            while (buffer < tmp_buffer_pointer) {
              if ( ((message->n_timer_ru_utime-1) & (message->n_timer_ru_utime)) == 0) {
                if (message->n_timer_ru_utime == 0) {
                  if ((message->timer_ru_utime = memory_allocate(8*sizeof(float), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                } else if (message->n_timer_ru_utime >= 8) {
                  void *new_ptr = memory_allocate_copy(2*message->n_timer_ru_utime*sizeof(float), allocator,
                    (uint8_t*)message->timer_ru_utime, message->n_timer_ru_utime*sizeof(float));
                  if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                  message->timer_ru_utime = new_ptr;
                }
              }
              if ((buffer=read_fixed32((uint32_t *)&message->timer_ru_utime[message->n_timer_ru_utime], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
              message->n_timer_ru_utime++;
            }
            if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0xb5:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ( ((message->n_timer_ru_utime-1) & (message->n_timer_ru_utime)) == 0) {
              if (message->n_timer_ru_utime == 0) {
                if ((message->timer_ru_utime = memory_allocate(8*sizeof(float), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              } else if (message->n_timer_ru_utime >= 8) {
                void *new_ptr = memory_allocate_copy(2*message->n_timer_ru_utime*sizeof(float), allocator,
                  (uint8_t*)message->timer_ru_utime, message->n_timer_ru_utime*sizeof(float));
                if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                message->timer_ru_utime = new_ptr;
              }
            }
            if ((buffer=read_fixed32((uint32_t *)&message->timer_ru_utime[message->n_timer_ru_utime], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            message->n_timer_ru_utime++;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0xba:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            tmp_buffer_pointer = buffer+t;
            if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
            while (buffer < tmp_buffer_pointer) {
              if ( ((message->n_timer_ru_stime-1) & (message->n_timer_ru_stime)) == 0) {
                if (message->n_timer_ru_stime == 0) {
                  if ((message->timer_ru_stime = memory_allocate(8*sizeof(float), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                } else if (message->n_timer_ru_stime >= 8) {
                  void *new_ptr = memory_allocate_copy(2*message->n_timer_ru_stime*sizeof(float), allocator,
                    (uint8_t*)message->timer_ru_stime, message->n_timer_ru_stime*sizeof(float));
                  if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                  message->timer_ru_stime = new_ptr;
                }
              }
              if ((buffer=read_fixed32((uint32_t *)&message->timer_ru_stime[message->n_timer_ru_stime], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
              message->n_timer_ru_stime++;
            }
            if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x3d:
        buffer += 1;
        if ((buffer=read_fixed32((uint32_t *)&message->request_time, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        required_fields[0] |= (1UL << 6);
        continue;
      case 0xa0:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ( ((message->n_tag_name-1) & (message->n_tag_name)) == 0) {
              if (message->n_tag_name == 0) {
                if ((message->tag_name = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              } else if (message->n_tag_name >= 8) {
                void *new_ptr = memory_allocate_copy(2*message->n_tag_name*sizeof(uint32_t), allocator,
                  (uint8_t*)message->tag_name, message->n_tag_name*sizeof(uint32_t));
                if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                message->tag_name = new_ptr;
              }
            }
            if ((buffer=read_uint32(&message->tag_name[message->n_tag_name], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            message->n_tag_name++;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x45:
        buffer += 1;
        if ((buffer=read_fixed32((uint32_t *)&message->ru_utime, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        required_fields[0] |= (1UL << 7);
        continue;
      case 0x4d:
        buffer += 1;
        if ((buffer=read_fixed32((uint32_t *)&message->ru_stime, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        required_fields[0] |= (1UL << 8);
        continue;
      case 0x50:
        buffer += 1;
        if ( ((message->n_timer_hit_count-1) & (message->n_timer_hit_count)) == 0) {
          if (message->n_timer_hit_count == 0) {
            if ((message->timer_hit_count = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
          } else if (message->n_timer_hit_count >= 8) {
            void *new_ptr = memory_allocate_copy(2*message->n_timer_hit_count*sizeof(uint32_t), allocator,
              (uint8_t*)message->timer_hit_count, message->n_timer_hit_count*sizeof(uint32_t));
            if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            message->timer_hit_count = new_ptr;
          }
        }
        if ((buffer=read_uint32(&message->timer_hit_count[message->n_timer_hit_count], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        message->n_timer_hit_count++;
        continue;
      case 0x52:
        buffer += 1;
        if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        tmp_buffer_pointer = buffer+t;
        if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        while (buffer < tmp_buffer_pointer) {
          if ( ((message->n_timer_hit_count-1) & (message->n_timer_hit_count)) == 0) {
            if (message->n_timer_hit_count == 0) {
              if ((message->timer_hit_count = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            } else if (message->n_timer_hit_count >= 8) {
              void *new_ptr = memory_allocate_copy(2*message->n_timer_hit_count*sizeof(uint32_t), allocator,
                (uint8_t*)message->timer_hit_count, message->n_timer_hit_count*sizeof(uint32_t));
              if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              message->timer_hit_count = new_ptr;
            }
          }
          if ((buffer=read_uint32(&message->timer_hit_count[message->n_timer_hit_count], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
          message->n_timer_hit_count++;
        }
        if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
        continue;
      case 0x5a:
        buffer += 1;
        if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        tmp_buffer_pointer = buffer+t;
        if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        while (buffer < tmp_buffer_pointer) {
          if ( ((message->n_timer_value-1) & (message->n_timer_value)) == 0) {
            if (message->n_timer_value == 0) {
              if ((message->timer_value = memory_allocate(8*sizeof(float), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            } else if (message->n_timer_value >= 8) {
              void *new_ptr = memory_allocate_copy(2*message->n_timer_value*sizeof(float), allocator,
                (uint8_t*)message->timer_value, message->n_timer_value*sizeof(float));
              if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              message->timer_value = new_ptr;
            }
          }
          if ((buffer=read_fixed32((uint32_t *)&message->timer_value[message->n_timer_value], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
          message->n_timer_value++;
        }
        if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
        continue;
      case 0x5d:
        buffer += 1;
        if ( ((message->n_timer_value-1) & (message->n_timer_value)) == 0) {
          if (message->n_timer_value == 0) {
            if ((message->timer_value = memory_allocate(8*sizeof(float), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
          } else if (message->n_timer_value >= 8) {
            void *new_ptr = memory_allocate_copy(2*message->n_timer_value*sizeof(float), allocator,
              (uint8_t*)message->timer_value, message->n_timer_value*sizeof(float));
            if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            message->timer_value = new_ptr;
          }
        }
        if ((buffer=read_fixed32((uint32_t *)&message->timer_value[message->n_timer_value], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        message->n_timer_value++;
        continue;
      case 0x60:
        buffer += 1;
        if ( ((message->n_timer_tag_count-1) & (message->n_timer_tag_count)) == 0) {
          if (message->n_timer_tag_count == 0) {
            if ((message->timer_tag_count = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
          } else if (message->n_timer_tag_count >= 8) {
            void *new_ptr = memory_allocate_copy(2*message->n_timer_tag_count*sizeof(uint32_t), allocator,
              (uint8_t*)message->timer_tag_count, message->n_timer_tag_count*sizeof(uint32_t));
            if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            message->timer_tag_count = new_ptr;
          }
        }
        if ((buffer=read_uint32(&message->timer_tag_count[message->n_timer_tag_count], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        message->n_timer_tag_count++;
        continue;
      case 0x62:
        buffer += 1;
        if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        tmp_buffer_pointer = buffer+t;
        if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        while (buffer < tmp_buffer_pointer) {
          if ( ((message->n_timer_tag_count-1) & (message->n_timer_tag_count)) == 0) {
            if (message->n_timer_tag_count == 0) {
              if ((message->timer_tag_count = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            } else if (message->n_timer_tag_count >= 8) {
              void *new_ptr = memory_allocate_copy(2*message->n_timer_tag_count*sizeof(uint32_t), allocator,
                (uint8_t*)message->timer_tag_count, message->n_timer_tag_count*sizeof(uint32_t));
              if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              message->timer_tag_count = new_ptr;
            }
          }
          if ((buffer=read_uint32(&message->timer_tag_count[message->n_timer_tag_count], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
          message->n_timer_tag_count++;
        }
        if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
        continue;
      case 0x68:
        buffer += 1;
        if ( ((message->n_timer_tag_name-1) & (message->n_timer_tag_name)) == 0) {
          if (message->n_timer_tag_name == 0) {
            if ((message->timer_tag_name = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
          } else if (message->n_timer_tag_name >= 8) {
            void *new_ptr = memory_allocate_copy(2*message->n_timer_tag_name*sizeof(uint32_t), allocator,
              (uint8_t*)message->timer_tag_name, message->n_timer_tag_name*sizeof(uint32_t));
            if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            message->timer_tag_name = new_ptr;
          }
        }
        if ((buffer=read_uint32(&message->timer_tag_name[message->n_timer_tag_name], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        message->n_timer_tag_name++;
        continue;
      case 0x6a:
        buffer += 1;
        if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        tmp_buffer_pointer = buffer+t;
        if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        while (buffer < tmp_buffer_pointer) {
          if ( ((message->n_timer_tag_name-1) & (message->n_timer_tag_name)) == 0) {
            if (message->n_timer_tag_name == 0) {
              if ((message->timer_tag_name = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            } else if (message->n_timer_tag_name >= 8) {
              void *new_ptr = memory_allocate_copy(2*message->n_timer_tag_name*sizeof(uint32_t), allocator,
                (uint8_t*)message->timer_tag_name, message->n_timer_tag_name*sizeof(uint32_t));
              if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              message->timer_tag_name = new_ptr;
            }
          }
          if ((buffer=read_uint32(&message->timer_tag_name[message->n_timer_tag_name], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
          message->n_timer_tag_name++;
        }
        if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
        continue;
      case 0x92:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ( ((message->n_requests-1) & (message->n_requests)) == 0) {
              if (message->n_requests == 0) {
                if ((message->requests = memory_allocate(8*sizeof(Pinba__Request*), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              } else if (message->n_requests >= 8) {
                void *new_ptr = memory_allocate_copy(2*message->n_requests*sizeof(Pinba__Request*), allocator,
                  (uint8_t*)message->requests, message->n_requests*sizeof(Pinba__Request*));
                if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                message->requests = new_ptr;
              }
            }
            if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
            buffer += length;
            
            {
              Pinba__Request *submessage_tmp = memory_allocate(sizeof(Pinba__Request), allocator);
              if (submessage_tmp == NULL) {
                return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              }
              pinba__request__init(submessage_tmp);
              t = pinba__request__unpack_merge(submessage_tmp, buffer-length, length, allocator);
              if (t < 0) {
                pinba__request__free_unpacked(submessage_tmp, allocator);
                return t;
              }
              message->requests[message->n_requests] = submessage_tmp;
            }
            
            message->n_requests++;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0xbd:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ( ((message->n_timer_ru_stime-1) & (message->n_timer_ru_stime)) == 0) {
              if (message->n_timer_ru_stime == 0) {
                if ((message->timer_ru_stime = memory_allocate(8*sizeof(float), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              } else if (message->n_timer_ru_stime >= 8) {
                void *new_ptr = memory_allocate_copy(2*message->n_timer_ru_stime*sizeof(float), allocator,
                  (uint8_t*)message->timer_ru_stime, message->n_timer_ru_stime*sizeof(float));
                if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                message->timer_ru_stime = new_ptr;
              }
            }
            if ((buffer=read_fixed32((uint32_t *)&message->timer_ru_stime[message->n_timer_ru_stime], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            message->n_timer_ru_stime++;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x70:
        buffer += 1;
        if ( ((message->n_timer_tag_value-1) & (message->n_timer_tag_value)) == 0) {
          if (message->n_timer_tag_value == 0) {
            if ((message->timer_tag_value = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
          } else if (message->n_timer_tag_value >= 8) {
            void *new_ptr = memory_allocate_copy(2*message->n_timer_tag_value*sizeof(uint32_t), allocator,
              (uint8_t*)message->timer_tag_value, message->n_timer_tag_value*sizeof(uint32_t));
            if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            message->timer_tag_value = new_ptr;
          }
        }
        if ((buffer=read_uint32(&message->timer_tag_value[message->n_timer_tag_value], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        message->n_timer_tag_value++;
        continue;
      case 0xa8:
        if (buffer + 1 >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        switch(buffer[1]) {
          case 0x1:
            buffer += 2;
            if ( ((message->n_tag_value-1) & (message->n_tag_value)) == 0) {
              if (message->n_tag_value == 0) {
                if ((message->tag_value = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              } else if (message->n_tag_value >= 8) {
                void *new_ptr = memory_allocate_copy(2*message->n_tag_value*sizeof(uint32_t), allocator,
                  (uint8_t*)message->tag_value, message->n_tag_value*sizeof(uint32_t));
                if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
                message->tag_value = new_ptr;
              }
            }
            if ((buffer=read_uint32(&message->tag_value[message->n_tag_value], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            message->n_tag_value++;
            continue;
          default:
            if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
            continue;
        }
        continue;
      case 0x72:
        buffer += 1;
        if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        tmp_buffer_pointer = buffer+t;
        if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        while (buffer < tmp_buffer_pointer) {
          if ( ((message->n_timer_tag_value-1) & (message->n_timer_tag_value)) == 0) {
            if (message->n_timer_tag_value == 0) {
              if ((message->timer_tag_value = memory_allocate(8*sizeof(uint32_t), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            } else if (message->n_timer_tag_value >= 8) {
              void *new_ptr = memory_allocate_copy(2*message->n_timer_tag_value*sizeof(uint32_t), allocator,
                (uint8_t*)message->timer_tag_value, message->n_timer_tag_value*sizeof(uint32_t));
              if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
              message->timer_tag_value = new_ptr;
            }
          }
          if ((buffer=read_uint32(&message->timer_tag_value[message->n_timer_tag_value], buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
          message->n_timer_tag_value++;
        }
        if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
        continue;
      case 0x7a:
        buffer += 1;
        if ( ((message->n_dictionary-1) & (message->n_dictionary)) == 0) {
          if (message->n_dictionary == 0) {
            if ((message->dictionary = memory_allocate(8*sizeof(char*), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
          } else if (message->n_dictionary >= 8) {
            void *new_ptr = memory_allocate_copy(2*message->n_dictionary*sizeof(char*), allocator,
              (uint8_t*)message->dictionary, message->n_dictionary*sizeof(char*));
            if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
            message->dictionary = new_ptr;
          }
        }
        if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
        if ((message->dictionary[message->n_dictionary] = memory_allocate_copy(length+1,
            allocator, buffer, length)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
        message->dictionary[message->n_dictionary][length] = 0;
        buffer += length;
        message->n_dictionary++;
        continue;
      default:
        if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
        continue;
    }
  }

  if (!(required_fields[0] == 0x1ffUL)) return PROTOBUF_C__WRONG_MESSAGE;
  return 0;
}

Pinba__Request *pinba__request__unpack
                     (ProtobufCAllocator *allocator,
                      size_t len, const uint8_t *data)
{
  if (allocator == NULL)
    allocator = &protobuf_c_default_allocator;
  Pinba__Request *m = memory_allocate(sizeof(*m), allocator);
  if (m == NULL) return NULL;
  pinba__request__init(m);
  if (0 > pinba__request__unpack_merge(m, data, len, allocator)) {
    pinba__request__free_unpacked(m, allocator);
    return NULL;
  }
  return m;
}

void pinba__request__free_unpacked
                     (Pinba__Request *message,
                      ProtobufCAllocator *allocator)
{
  if (allocator == NULL)
    allocator = &protobuf_c_default_allocator;
  unsigned i;
  memory_free(message->hostname, allocator);
  memory_free(message->server_name, allocator);
  memory_free(message->script_name, allocator);
  memory_free(message->timer_hit_count, allocator);
  memory_free(message->timer_value, allocator);
  memory_free(message->timer_tag_count, allocator);
  memory_free(message->timer_tag_name, allocator);
  memory_free(message->timer_tag_value, allocator);
  for (i = 0; i < message->n_dictionary; i++) {
    memory_free(message->dictionary[i], allocator);
  }
  memory_free(message->dictionary, allocator);
  for (i = 0; i < message->n_requests; i++) {
    if (message->requests[i] != NULL) pinba__request__free_unpacked(message->requests[i], allocator);
  }
  memory_free(message->requests, allocator);
  memory_free(message->schema, allocator);
  memory_free(message->tag_name, allocator);
  memory_free(message->tag_value, allocator);
  memory_free(message->timer_ru_utime, allocator);
  memory_free(message->timer_ru_stime, allocator);
  memory_free(message, allocator);
}

protobuf_c_boolean pinba__request__check
                     (const Pinba__Request *message)
{
  unsigned i;
  if (message == NULL || message->base.descriptor != &pinba__request__descriptor)
    return 0;
  if (message->hostname == NULL) return 0;
  if (message->server_name == NULL) return 0;
  if (message->script_name == NULL) return 0;
  if (message->n_timer_hit_count > 0 && message->timer_hit_count == NULL) return 0;
  if (message->n_timer_value > 0 && message->timer_value == NULL) return 0;
  if (message->n_timer_tag_count > 0 && message->timer_tag_count == NULL) return 0;
  if (message->n_timer_tag_name > 0 && message->timer_tag_name == NULL) return 0;
  if (message->n_timer_tag_value > 0 && message->timer_tag_value == NULL) return 0;
  if (message->n_dictionary > 0 && message->dictionary == NULL) return 0;
  for (i = 0; i < message->n_dictionary; i++) {
    if (message->dictionary[i] == NULL) return 0;
  }
  if (message->n_requests > 0 && message->requests == NULL) return 0;
  for (i = 0; i < message->n_requests; i++) {
    if (!pinba__request__check(message->requests[i])) return 0;
  }
  if (message->n_tag_name > 0 && message->tag_name == NULL) return 0;
  if (message->n_tag_value > 0 && message->tag_value == NULL) return 0;
  if (message->n_timer_ru_utime > 0 && message->timer_ru_utime == NULL) return 0;
  if (message->n_timer_ru_stime > 0 && message->timer_ru_stime == NULL) return 0;
  return 1;
}

// @@protoc_insertion_point(pinba__request)
static const ProtobufCFieldDescriptor pinba__request__field_descriptors[23] =
{
  {
    "hostname",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, hostname),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "server_name",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, server_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "script_name",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, script_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "request_count",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, request_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "document_size",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, document_size),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "memory_peak",
    6,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, memory_peak),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "request_time",
    7,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FLOAT,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, request_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ru_utime",
    8,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FLOAT,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, ru_utime),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ru_stime",
    9,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FLOAT,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, ru_stime),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "timer_hit_count",
    10,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, n_timer_hit_count),
    offsetof(Pinba__Request, timer_hit_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "timer_value",
    11,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(Pinba__Request, n_timer_value),
    offsetof(Pinba__Request, timer_value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "timer_tag_count",
    12,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, n_timer_tag_count),
    offsetof(Pinba__Request, timer_tag_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "timer_tag_name",
    13,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, n_timer_tag_name),
    offsetof(Pinba__Request, timer_tag_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "timer_tag_value",
    14,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, n_timer_tag_value),
    offsetof(Pinba__Request, timer_tag_value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dictionary",
    15,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_STRING,
    offsetof(Pinba__Request, n_dictionary),
    offsetof(Pinba__Request, dictionary),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "status",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, has_status),
    offsetof(Pinba__Request, status),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "memory_footprint",
    17,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, has_memory_footprint),
    offsetof(Pinba__Request, memory_footprint),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "requests",
    18,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pinba__Request, n_requests),
    offsetof(Pinba__Request, requests),
    &pinba__request__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "schema",
    19,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Pinba__Request, schema),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tag_name",
    20,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, n_tag_name),
    offsetof(Pinba__Request, tag_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tag_value",
    21,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Pinba__Request, n_tag_value),
    offsetof(Pinba__Request, tag_value),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "timer_ru_utime",
    22,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(Pinba__Request, n_timer_ru_utime),
    offsetof(Pinba__Request, timer_ru_utime),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "timer_ru_stime",
    23,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(Pinba__Request, n_timer_ru_stime),
    offsetof(Pinba__Request, timer_ru_stime),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned pinba__request__field_indices_by_name[] = {
  14,   /* field[14] = dictionary */
  4,   /* field[4] = document_size */
  0,   /* field[0] = hostname */
  16,   /* field[16] = memory_footprint */
  5,   /* field[5] = memory_peak */
  3,   /* field[3] = request_count */
  6,   /* field[6] = request_time */
  17,   /* field[17] = requests */
  8,   /* field[8] = ru_stime */
  7,   /* field[7] = ru_utime */
  18,   /* field[18] = schema */
  2,   /* field[2] = script_name */
  1,   /* field[1] = server_name */
  15,   /* field[15] = status */
  19,   /* field[19] = tag_name */
  20,   /* field[20] = tag_value */
  9,   /* field[9] = timer_hit_count */
  22,   /* field[22] = timer_ru_stime */
  21,   /* field[21] = timer_ru_utime */
  11,   /* field[11] = timer_tag_count */
  12,   /* field[12] = timer_tag_name */
  13,   /* field[13] = timer_tag_value */
  10,   /* field[10] = timer_value */
};
static const ProtobufCIntRange pinba__request__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 23 }
};
const ProtobufCMessageDescriptor pinba__request__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Pinba.Request",
  "Request",
  "Pinba__Request",
  "Pinba",
  sizeof(Pinba__Request),
  23,
  pinba__request__field_descriptors,
  pinba__request__field_indices_by_name,
  1,  pinba__request__number_ranges,
  (ProtobufCMessageInit) pinba__request__init,
  (ProtobufCMessageGetPackedSize) pinba__request__get_packed_size,
  (ProtobufCMessagePack) pinba__request__pack,
  (ProtobufCMessagePackToBuffer) pinba__request__pack_to_buffer,
  (ProtobufCMessageUnpack) pinba__request__unpack,
  (ProtobufCMessageFreeUnpacked) pinba__request__free_unpacked,
  (ProtobufCMessageCheck) pinba__request__check,
  NULL,NULL,NULL    /* reserved[123] */
};
