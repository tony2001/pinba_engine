/* This file is autogenerated, edit the original template instead! */

/* Copyright (c) 2007-2013 Antony Dovgal <tony@daylessday.org>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

static inline pinba_report *pinba_regenerate_report_info(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report_info_data *data;
	/*struct pinba_report9_data *data;*/
	;
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT_INFO/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report_info_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report_info_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 1
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report_info_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report_info_data/*struct pinba_report9_data*/));

				;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report_info_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report1(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report1_data *data;
	/*struct pinba_report9_data *data;*/
	const uint8_t *index;
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT1/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report1_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report1_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			index = (const uint8_t *)record->data.script_name;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report1_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report1_data/*struct pinba_report9_data*/));

				;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report1_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report2(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report2_data *data;
	/*struct pinba_report9_data *data;*/
	const uint8_t *index;
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT2/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report2_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report2_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			index = (const uint8_t *)record->data.server_name;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report2_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report2_data/*struct pinba_report9_data*/));

				;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report2_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report3(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report3_data *data;
	/*struct pinba_report9_data *data;*/
	const uint8_t *index;
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT3/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report3_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report3_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			index = (const uint8_t *)record->data.hostname;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report3_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report3_data/*struct pinba_report9_data*/));

				;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report3_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report4(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report4_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_SERVER_NAME_SIZE + PINBA_SCRIPT_NAME_SIZE + 1] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT4/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report4_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report4_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.server_name, record->data.server_name_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report4_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report4_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->server_name, record->data.server_name, record->data.server_name_len, dummy);
		memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report4_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report5(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report5_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_HOSTNAME_SIZE + PINBA_SCRIPT_NAME_SIZE + 1] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT5/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report5_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report5_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.hostname, record->data.hostname_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report5_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report5_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report5_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report6(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report6_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_HOSTNAME_SIZE + PINBA_SERVER_NAME_SIZE + 1] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT6/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report6_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report6_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.hostname, record->data.hostname_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.server_name, record->data.server_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report6_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report6_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		memcpy_static(data->server_name, record->data.server_name, record->data.server_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report6_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report7(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report7_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_HOSTNAME_SIZE + 1 + PINBA_SERVER_NAME_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT7/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report7_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report7_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.hostname, record->data.hostname_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = ':' : 0;
		memcat_static(index, index_len, record->data.server_name, record->data.server_name_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report7_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report7_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		memcpy_static(data->server_name, record->data.server_name, record->data.server_name_len, dummy);
		memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report7_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report8(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report8_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_STATUS_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT8/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report8_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report8_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		sprintf((char *)index, "%u", record->data.status);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report8_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report8_data/*struct pinba_report9_data*/));

				
		data->status = record->data.status;
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report8_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report9(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report9_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT9/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report9_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report9_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
        index_len = sprintf((char *)index, "%u:", record->data.status);
        memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report9_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report9_data/*struct pinba_report9_data*/));

				
		data->status = record->data.status;
		memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report9_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report10(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report10_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SERVER_NAME_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT10/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report10_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report10_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		index_len = sprintf((char *)index, "%u", record->data.status);
		memcat_static(index, index_len, record->data.server_name, record->data.server_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report10_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report10_data/*struct pinba_report9_data*/));

				
		data->status = record->data.status;
		memcpy_static(data->server_name, record->data.server_name, record->data.server_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report10_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report11(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report11_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_HOSTNAME_SIZE + 1 + PINBA_STATUS_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT11/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report11_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report11_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		index_len = sprintf((char *)index, "%u", record->data.status);
		memcat_static(index, index_len, record->data.hostname, record->data.hostname_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report11_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report11_data/*struct pinba_report9_data*/));

				
		data->status = record->data.status;
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report11_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report12(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report12_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_HOSTNAME_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT12/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report12_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report12_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

					index_len = sprintf((char *)index, "%u", record->data.status);
		memcat_static(index, index_len, record->data.hostname, record->data.hostname_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report12_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report12_data/*struct pinba_report9_data*/));

				
		data->status = record->data.status;
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report12_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report13(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report13_data *data;
	/*struct pinba_report9_data *data;*/
	const uint8_t *index;
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT13/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report13_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report13_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			index = (const uint8_t *)record->data.schema;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report13_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report13_data/*struct pinba_report9_data*/));

				;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report13_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report14(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report14_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_SCHEMA_SIZE + PINBA_SCRIPT_NAME_SIZE + 1] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT14/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report14_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report14_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.schema, record->data.schema_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = ':' : 0;
		memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report14_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report14_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->schema, record->data.schema, record->data.schema_len, dummy);
		memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report14_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report15(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report15_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_SCHEMA_SIZE + PINBA_SERVER_NAME_SIZE + 1] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT15/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report15_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report15_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.schema, record->data.schema_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = ':' : 0;
		memcat_static(index, index_len, record->data.server_name, record->data.server_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report15_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report15_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->schema, record->data.schema, record->data.schema_len, dummy);
		memcpy_static(data->server_name, record->data.server_name, record->data.server_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report15_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report16(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report16_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_SCHEMA_SIZE + PINBA_HOSTNAME_SIZE + 1] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT16/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report16_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report16_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.schema, record->data.schema_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = ':' : 0;
		memcat_static(index, index_len, record->data.hostname, record->data.hostname_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report16_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report16_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->schema, record->data.schema, record->data.schema_len, dummy);
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report16_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report17(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report17_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_SCHEMA_SIZE + 1 + PINBA_HOSTNAME_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT17/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report17_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report17_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

			
		memcpy_static(index, record->data.schema, record->data.schema_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.hostname, record->data.hostname_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
		;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report17_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report17_data/*struct pinba_report9_data*/));

				
		memcpy_static(data->schema, record->data.schema, record->data.schema_len, dummy);
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report17_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */


static inline pinba_report *pinba_regenerate_report18(PINBA_SHARE *share)/* pinba_regenerate_report9(PINBA_SHARE *share) */ /* {{{ */
{
	PPvoid_t ppvalue;
	pinba_report *report;
	pinba_pool *p = &D->request_pool;
	pinba_stats_record *record;
	unsigned int i;
	struct pinba_report18_data *data;
	/*struct pinba_report9_data *data;*/
	uint8_t index[PINBA_SCHEMA_SIZE + 1 + PINBA_HOSTNAME_SIZE + 1 + PINBA_STATUS_SIZE] = {0};
	/*uint8_t index[PINBA_STATUS_SIZE + 1 + PINBA_SCRIPT_NAME_SIZE] = {0};*/

	if (share->index[0] == '\0') {
		pinba_get_report_id(share);
	}

	ppvalue = JudySLGet(D->base_reports, share->index, NULL);
	if (!ppvalue) {

		report = (pinba_report *)calloc(1, sizeof(pinba_report));
		if (!report) {
			return NULL;
		}

		pinba_parse_conditions(share, (pinba_std_report *)report);

		report->std.type = PINBA_TABLE_REPORT18/*PINBA_TABLE_REPORT9*/;
		report->add_func = pinba_update_report18_add/*pinba_update_report9_add*/;
		report->delete_func = pinba_update_report18_delete/*pinba_update_report9_delete*/;
		pthread_rwlock_init(&report->lock, 0);
		pthread_rwlock_wrlock(&report->lock);

		ppvalue = JudySLIns(&D->base_reports, share->index, NULL);
		if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			pinba_std_report_dtor(report);
			free(report);
			return NULL;
		}

		if (pinba_base_reports_array_add(report) < 0) {
			JudySLDel(&D->base_reports, share->index, NULL);
			pthread_rwlock_unlock(&report->lock);
			pthread_rwlock_destroy(&report->lock);
			free(report);
			return NULL;
		}
		*ppvalue = report;
	} else {
		report = (pinba_report *)*ppvalue;
		return report;
	}

	pool_traverse_forward(i, p) {
		record = REQ_POOL(p) + i;

		CHECK_REPORT_CONDITIONS_CONTINUE(report, record);

		timeradd(&report->time_total, &record->data.req_time, &report->time_total);
		timeradd(&report->ru_utime_total, &record->data.ru_utime, &report->ru_utime_total);
		timeradd(&report->ru_stime_total, &record->data.ru_stime, &report->ru_stime_total);
		report->kbytes_total += record->data.doc_size;
		report->memory_footprint += record->data.memory_footprint;
		
#if 0
		report->results_cnt++;
		PINBA_UPDATE_HISTOGRAM_ADD(report, report->std.histogram_data, record->data.req_time);
#else
		{
			int index_len, dummy;
			/*int index_len, dummy;*/

					index_len = sprintf((char *)index, "%u:", record->data.status);
		memcat_static(index, index_len, record->data.schema, record->data.schema_len, index_len);
		(index_len < sizeof(index)-1) ? index[index_len++] = '/' : 0;
		memcat_static(index, index_len, record->data.hostname, record->data.hostname_len, index_len);;
			/*
			   index_len = sprintf((char *)index, "%u:", record->data.status);
			   memcat_static(index, index_len, record->data.script_name, record->data.script_name_len, index_len);
			   */
			ppvalue = JudySLGet(report->results, index, NULL);

			if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
				/* no such value, insert */
				ppvalue = JudySLIns(&report->results, index, NULL);
				if (UNLIKELY(!ppvalue || ppvalue == PPJERR)) {
					pthread_rwlock_unlock(&report->lock);
					return NULL;
				}
				data = (struct pinba_report18_data /*struct pinba_report9_data*/ *)calloc(1, sizeof(struct pinba_report18_data/*struct pinba_report9_data*/));

				
		data->status = record->data.status;
		memcpy_static(data->schema, record->data.schema, record->data.schema_len, dummy);
		memcpy_static(data->hostname, record->data.hostname, record->data.hostname_len, dummy);
		;
				/*
				   memcpy_static(data->script_name, record->data.script_name, record->data.script_name_len, dummy);
				   data->status = record->data.status;
				   */
				*ppvalue = data;
				report->results_cnt++;
			} else {
				data = (struct pinba_report18_data /*struct pinba_report9_data*/ *)*ppvalue;
			}
			data->req_count++;
			timeradd(&data->req_time_total, &record->data.req_time, &data->req_time_total);
			timeradd(&data->ru_utime_total, &record->data.ru_utime, &data->ru_utime_total);
			timeradd(&data->ru_stime_total, &record->data.ru_stime, &data->ru_stime_total);
			data->kbytes_total += record->data.doc_size;
			data->memory_footprint += record->data.memory_footprint;
			PINBA_UPDATE_HISTOGRAM_ADD(report, data->histogram_data, record->data.req_time);
		}
#endif
	}
	report->time_interval = pinba_get_time_interval();
	pthread_rwlock_unlock(&report->lock);
	return report;
}
/* }}} */

